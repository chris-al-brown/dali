# Dali language specification and code samples

# Notes
# unused characters: @ $ % ^ & ' ; ?
# control flow: lazy sequences and predicates
# type system: static typing with an optional type
# drawing output: stdin, stdout, stderr, stdcvs (standard canvas)
# support for functions, closures, classes?

# Comments

    # This is a comment because it begins with #

# Primitives datatypes

    # A number literal
    variable: 1.0

    # A string literal
    single: "This is a single line string."
    multiple: "This is
    a multiline version
    of the string."

    # A boolean literal
    variable: true
    variable: false

    # A nonexistent value
    variable: none

# Composite datatypes

    # A relational type (i.e. hash, map, dictionary, etc.)
    person: (name: "Chris", address: "101 Rivera Boulevard")
    person.name
    person.address: "102 Rivera Boulevard"

    # A sequential type (i.e. array, list, etc.)
    numbers: (0.0, 2.0, 4.0, 6.0, 8.0, 10.0)
    numbers[0]
    numbers[3]: 10.0

    booleans: (true, false, true, false)
    booleans[3]

    # An invalid mixed datatype
    (name: "Chris", 0.0, 1.0, 2.0)

    # Accessors

        # Getter (short hand for .? and [?])
        get(from:person key:"name")
        get(from:numbers index:3)

        # Setter (short hand for .?: and [?]:)
        set(to:person key:"name" value:"Bill")
        set(to:numbers index:3 value:100.1)

# Arithmetic

    # Addition
    third: first + second

    # Subtraction
    third: first - second

    # Multiplication
    third: first * second

    # Division
    third: first / second

    # Negation
    third: -first

# Comparison

    # Equality
    first = second

    # Less than
    first < second

    # Greater than
    first > second

# Logical

    # Negation
    !(first = second)

    # And
    first & second

    # Or
    first | second | third

    # Grouping
    value: ((true & true) | false)

# Statements

    # Single
    first: 1.0
    second: 2.0
    first + second

    # Multiple
    first: 1.0, second: 2.0, third: 3.0
    first + second + third

# Functions

    # Anonymous
    { (first:second:) first + second }

    # Named ("add:first:second:" for multiple dispatch and simple name mangling)
    add: { (first:second:) first + second }

    # Execution
    add(first:1.0, second:2.0)              # 3.0
    add(first:"Hello ", second:"world")     # "Hello world"





# Sketching

# Slices are not supported
# reduce: { (value:array:) reduce(value:value + array[0], array: array[1:]) }

# Sequences
# - lambda, map, reduce, filter
# Create sequences (lattice(), series(), ...)
# Change sequences (map: sequence1 + sequence2 => (type1 = type2))
# Sample sequences (filter:)
# Manipulate sequences (lambda:)

# Functional programming primitives: reduce, filter, map

    reduce(from:where:)
    filter(from:where:)
    sample(from:where:)
    sample(from:where:count:)

# Context

    # @ (this, self, etc.)
    # @.x
    # @.y
    # @.count
    # @.@ (parent context)
    # @.@.@...@ => none eventually

# Standard library

    debug()
    draw()
    dump()
    import()
    loop()
    print()
    show()

# Modules

    # Colors

    color(gray:)
    color(red:green:blue:)
    color(red:green:blue:alpha:)
    color(hue:saturation:brightness:)
    color(hue:saturation:brightness:alpha:)

    # Constant

    pi
    e
    sqrt2
    sqrt3

    # Geometry

    point(x:y:)
    size(width:height:)
    line(from:to:)
    line(slope:intercept:)
    circle(x:y:radius:)
    circle(origin:radius:)
    triangle(origin:radius:)
    triangle(p1:p2:p3:)
    square(origin:radius:)
    rectangle(origin:size:)
    polygon(points:)

    # Isometry

    # glide
    # reflect
    # rotate
    # translate

    # Lattice (bravais)

    # hexagonal
    # oblique
    # rectangular (centered-rectangular, square)

    # Math

    abs()
    cos()
    exp()
    log()
    max()
    min()
    mod()
    sin()

    # Measurement

    area(of:)
    distance(from:to:)
    distance(from:to:metric:)
    length(of:)

    # Noise

    perlin(x)
    perlin(x:y:)
    perlin(x:y:z:)
    # simplex(x)
    # simplex(x:y:)
    # simplex(x:y:z:)

    # Random

    random()
    gaussian(mean:stddev:)
    uniform(min:max:)

    # Series

    range(from:to:)
    # arithmetic
    # fourier
    # geometric
    # harmonic

    # Symmetry

    # mirror?


