# Dali language specification and code samples

# Notes
# unused characters: @ [ ] { } $ % ^ & ' ; ?
# control flow: lazy sequences and filters
# type system: static typing with an optional type
# drawing output: stdin, stdout, stderr, stdcvs (standard canvas)

# Comments

    # This is a comment because it begins with #

# Primitives datatypes

    # A number literal
    variable: 1.0

    # A string literal
    single: "This is a single line string."
    multiple: "This is
    a multiline version
    of the string."

    # A boolean literal
    variable: true
    variable: false

    # A nonexistent value
    variable: none

# Composite datatypes

    # A record type (i.e. hash, map, dictionary, etc.)
    person: (name: "Chris" address: "101 Rivera Boulevard")
    person.name
    person.address: "102 Rivera Boulevard"

    # A homogenous sequential type (i.e. array, list, etc.)
    numbers: (0.0, 2.0, 4.0, 6.0, 8.0, 10.0)
    numbers[0]
    numbers[3]: 10.0

    booleans: (true, false, true, false)
    booleans[3]

    # An invalid mixed datatype
    (name: "Chris", 0.0, 1.0, 2.0)

    # Accessors

        # Getter (short hand for .? and [?])
        get(from:person key:"name")
        get(from:numbers index:3)

        # Setter (short hand for .?: and [?]:)
        set(to:person key:"name" value:"Bill")
        set(to:numbers index:3 value:100.1)

# Arithmetic

    # Addition
    third: first + second

    # Subtraction
    third: first - second

    # Multiplication
    third: first * second

    # Division
    third: first / second

    # Negation
    third: -first

# Comparison

    # Equality
    first = second

    # Less than
    first < second

    # Greater than
    first > second

# Logical

    # Negation
    !(first = second)

    # And
    first & second

    # Or
    first | second | third

    # Grouping
    value: ((true & true) | false)

# Statements

    # Single
    first: 1.0
    second: 2.0
    first + second

    # Multiple
    (first: 1.0, second: 2.0, first + second)





# Sketching

# Control flow ...

# Sequences

filter(from:where:)

sample(from:count:)
sample(from:)
sample(from:using:)
sample(from:where:)

# Standard library

debug(source:)
print(string:)

# Geometry / Sequences / Lattices

point(x:y:)
size(width:height:)

line(from:to:)
line(slope:intercept:)

circle(x:y:radius:)
circle(origin:radius:)

triangle(origin:radius:)
triangle(p1:p2:p3:)

square(origin:radius:)

rectangle(origin:size:)

polygon(points:)


my_origin: point(x: 0.0, y: 0.0)
my_circle: circle(origin: origin, radius: 1.0)
my_sample: sample(from: my_circle, count: 10)

# circle: (x:x_sequence y:y_sequence radius:1.0)

# Accessors & execution
circle: (x: y: radius:)

# Interior, exterior, boundary geometry
(sample: (circle: x: y: radius:) count:)
(sample: (circle: y: x: radius:) count:)
(sample: (circle: radius: x: y:) count:)


# function: arg1: arg2: arg3: ... argN:
# function: [arg1: arg2: arg3: ... argN:] ()
# sample: [shape:count:]()


# Grouping expressions
circle: x: y: radius:
circle: (x: y: radius:)
(circle: x: y: radius:)
circle: x: (y: radius:)

# Control flow

# Switch

switch:junk key1:one key2:two key3:three

switch:variable
    case: value1
        # do something
    case: value2
        # do something
    case: value3
        # do something
    default:
        # do something

# Iteration

# What should be printed?

    print: circle: _ x: 0.0 y: 0.0   radius: 1.0 _

    # vs

    print: circle:   x: 0.0 y: 0.0 _ radius: 1.0 _







junk: .123
