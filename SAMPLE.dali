# Dali language specification and code samples

# Notes
# unused characters: $ % ^ & ' ; ?
# control flow: lazy sequences and predicates
# type system: static typing with an optional type
# supported types: boolean, number, string, list, map, function
# drawing output: stdin, stdout, stderr, stdcvs (standard canvas)
# how to deal with function lookup, name mangling, multiple dispatch
# support for subclassing and variable lookup chains
# support for optional and none values

# Comments

    # This is a comment because it begins with #

# Datatypes

    # Primitives

        # A number value
        variable: 1.0

        # A string value (multiline strings not supported)
        single: "This is a single line string."

        # A boolean value
        variable: true

    # Compositions
    	
        # A map (i.e. hash, dictionary, record, etc.)
        person: {
            name: "Chris",
            age: 34,
            address: "101 Rivera Boulevard"
        }
        person[name]
        person[address]: "102 Rivera Boulevard"

        # A list (i.e. array, etc.)
        numbers: [0.0,
            2.0, 4.0, 6.0,
            8.0, 10.0
        ]
        numbers[0]
        numbers[3]: numbers[3] + 10.0

        booleans: [true, false, true, false]
        booleans[3]

        mixed: [false, 1.0, "Hello world"]
        mixed[0]: 0.0

# Operators

    # Arithmetic

        # Addition
        third: first + second

        # Subtraction
        third: first - second

        # Multiplication
        third: first * second

        # Division
        third: first / second

        # Negation
        third: -first

    # Comparison

        # Equality
        first = second

        # Less than
        first < second

        # Greater than
        first > second

    # Logical

        # Negation
        !(first = second)

        # And
        first & second

        # Or
        first | second | third

        # Grouping
        value: ((true & true) | false)

# Statements

    # Single
    first: 1.0
    second: 2.0
    first + second

    # Multiple
    # first: 1.0, second: 0.2, third: 3
    # first + second + third

# Functions

    # Anonymous (i.e. lambda)
    @( first, second ) { first + second }

    # Named
    adder: @( first, second ) {
        first + second # Return this
    }

    # Execution
    adder(first:1.0, second:2.0)              # 3.0
    adder(first:"Hello ", second:"world")     # "Hello world"

# Sketching

# Slices are not supported
# reduce: { (value:array:) reduce(value:value + array[0], array: array[1:]) }

# Sequences
# - lambda, map, reduce, filter
# Create sequences (lattice(), series(), ...)
# Change sequences (map: sequence1 + sequence2 => (type1 = type2))
# Sample sequences (filter:)
# Manipulate sequences (lambda:)

# Functional programming primitives: reduce, filter, map

# reduce(from:where:)
# filter(from:where:)
# sample(from:where:)
# sample(from:where:count:)

# Context

    # @ (this, self, etc.)
    # @.x
    # @.y
    # @.count
    # @.@ (parent context)
    # @.@.@...@ => none eventually

# Standard library

    debug()
    draw()
    dump()
    import()
    loop()
    print()
    show()

# Modules

    # Colors

    # color(gray:)
    # color(red:green:blue:)
    # color(red:green:blue:alpha:)
    # color(hue:saturation:brightness:)
    # color(hue:saturation:brightness:alpha:)

    # Constant

    pi
    e
    sqrt2
    sqrt3

    # Geometry

    # point(x:y:)
    # size(width:height:)
    # line(from:to:)
    # line(slope:intercept:)
    # circle(x:y:radius:)
    # circle(origin:radius:)
    # triangle(origin:radius:)
    # triangle(p1:p2:p3:)
    # square(origin:radius:)
    # rectangle(origin:size:)
    # polygon(points:)

    # Isometry

    # glide
    # reflect
    # rotate
    # translate

    # Lattice (bravais)

    # hexagonal
    # oblique
    # rectangular (centered-rectangular, square)

    # Math

    abs()
    cos()
    exp()
    log()
    max()
    min()
    mod()
    sin()

    # Measurement

    # area(of:)
    # distance(from:to:)
    # distance(from:to:metric:)
    # length(of:)

    # Noise

    # perlin(x)
    # perlin(x:y:)
    # perlin(x:y:z:)
    # simplex(x)
    # simplex(x:y:)
    # simplex(x:y:z:)

    # Random

    # random()
    # gaussian(mean:stddev:)
    # uniform(min:max:)

    # Series

    # range(from:to:)
    # arithmetic
    # fourier
    # geometric
    # harmonic

    # Symmetry

    # mirror?
